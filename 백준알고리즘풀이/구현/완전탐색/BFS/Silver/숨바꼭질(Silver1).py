# 9:50~10:08 / 10:13~  - 중복순열로 풀었다가 메모리초과로 실패

# 수빈 N, # 동생 K
    # 걷거나 순간이동 가능
    # 걷기
        # 1초후에 X-1 또는 X + 1로 이동
    # 순간이동
        # 1초후에 2*X로 이동

# answer : 수빈이가 동생 찾을 수 있는 가장 빠른시간 몇 초인지
# bfs로 해결
# =====================================================
from collections import deque

# answer
answer = 0
# n, k 입력
n, k = map(int, input().split())
# 시간초과 나지 않도록 수 제한
# 주의 - 1e6은 float이기 때문에 int형으로 사용하기 위해서는 int로 형변환 해야함
MAX = int(1e6)
# 수빈이가 각 위치에 도달하기 위해 걸리는 시간
# 해당 위치를 방문했는지 방문여부도 체크하는 용도로 사용
time = [0] * (MAX + 1)

# 시작점 추가
q = deque([n])
while q:
    # 현재 수빈이 위치
    x = q.popleft()
    # 만약 수빈이 위치가 동생의 위치와 같다면
    if x == k:
        # 수빈이의 출발지점부터 현재 위치까지 오는데 걸리는 시간 출력
        answer = time[x]
        break
    # 이동할수 있는 위치를 반복하면서
    for nx in (x - 1, x + 1, x * 2):
        # 만약 이동할 위치가 제한된 범위 내에 있고, 아직 이동할 위치에 온적이 없다면(온적이 있는 경우 중복방문이므로 queue에 넣어서 탐색할 필요없음)
        if 0 <= nx <= MAX and not time[nx]:
            # 이동할 위치로 가는 시간 계산
            # 현재 위치에서 이동할 위치로 갈때 어떤 방법이든 1초 걸리므로 1 증가시켜 갱신
            time[nx] = time[x] + 1
            # 이동할 위치를 queue에 넣어서 방문하기
            q.append(nx)

print(answer)