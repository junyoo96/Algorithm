# n : 식량창고 개수
    # 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있음
    # 개미전사가 정찰병들에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고 약탈해야함
# answer : 얻을 수 있는 식량의 최댓값
# 점화식
    # 1. 점화식 초기값 처리
        # a0 = 0
        # a1 = max(첫번째 식량 수, 두번재 식량 수)
    # 2. 점화식
        # ai = max(ai-1 , ai-2 + ai의 식량 수)
            # 즉, (현재 창고 식량 + 2칸 왼쪽에 있는 창고 식량) vs (1칸 왼쪽에 있는 창고 식량만, 현재창고실량은 못털고) 중 최댓값을 현재 자리에 얻을 수 있는 최댓값으로 저장
#=====================================================================================================================================================
n = int(input())
array = list(map(int, input.split()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 1. 점화식 초기값 처리
# 다이나믹 프로그래밍 진행(Bottom-Up 방식)
d[0] = array[0]
# 첫번재 식량 수와 두번째 식량 수 중 최댓값 설정
d[1] = max(array[0], array[1])
# 2. 점화식
# 3번째 식량부터 반복하면서
for i in range(2, n):
    # (현재 창고 식량 + 2칸 왼쪽에 있는 창고 식량) vs (1칸 왼쪽에 있는 창고 식량만, 현재창고실량은 못털고) 를 비교해서 더 많은 식량을 터는 경우를 고르기
    d[i] = max(d[i-1], d[i-2] + array[i])

# 계산된 얻을 수 있는 식량의 최댓값 출력
# DP테이블 마지막칸에 계산해 얻을 수 있는 식량의 최댓값이 계산되어 있음
print(d[n-1])