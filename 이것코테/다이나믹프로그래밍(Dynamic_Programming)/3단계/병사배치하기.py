n = int(input()) # 병사 수
array = list(map(int, input().split())) # 병사 전투력 리스트
# 현재 문제는 전투력이 높은 병사가 앞쪽에 오는 내림차순 배치가 되도록 빼야되는 병사의 가장 작은 값을 구하는 문제이기 때문에
    # 이 문제를 '가장 긴 감소하는 부분 수열'의 길이를 계산하는 문제로 간주하고
    # 입력으로 주어진 원소의 순서를 뒤집은 뒤에 '가장 긴 증가하는 부분 수열' 문제를 풀때의 점화식을 그대로 적용하여 해결하기 위함
array.reverse()

# 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화(각 숫자의 크기 순위(숫자가 클수록 큰 숫자)를 저장하기 위해 모두 1로 초기화)
dp = [1] * n

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
for i in range(1,n): # 순위를 알고자 하는 타겟 숫자
    for j in range(0, i): # 타켓 숫자와 순위를 비교하고자 하는 숫자
        # 만약 타겟 숫자가 비교하는 숫자보다 더 크다면
        if array[j] < array[i]:
            # 타겟 숫자의 현재 순위와 (비교하고자 하는 숫자의 순위 + 1)을 비교했을 때 더 큰것을 타켓 숫자의 순위로 갱신
                # 즉, 타켓 숫자가 더 크니까 비교하고자 하는 숫자보다 순위 하나만 더 크면 되기 때문
            dp[i] = max(dp[i], dp[j] + 1)

# 전체 숫자 개수에서 dp테이블의 최고 순위만큼 빼면 오름차순 정렬을 위해 빼도 되는 숫자의 개수가 나옴
print(n - max(dp))

